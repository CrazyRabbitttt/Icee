## ：C语言

- const的作用有哪些，谈一谈你对const的理解？包括 static 的使用（函数、变量、是否是类内部的）

> - 修饰变量：限定变量不能够进行更改
> - 修饰函数(形参、函数整体、返回值)
> - 修饰指针（指针常量和常量指针）

- 描述char*、const char*、char* const、const char* const的区别？

- 指针常量和常量指针有什么区别？

- static的作用是什么，什么情况下用到static？

- 全局变量与局部变量的区别？

> ​	变量什么时间会被销毁？

- 宏定义的作用是什么？

[#define宏常量和const常量的区别](https://github.com/guaguaupup/cpp_interview/blob/main/C%2B%2B.md#define%E5%AE%8F%E5%B8%B8%E9%87%8F%E5%92%8Cconst%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB)

- 内存对齐的概念？为什么会有内存对齐？

> [struct 内存对齐的规则](https://github.com/guaguaupup/cpp_interview/blob/main/C%2B%2B.md#struct%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99) 按照 struct 中的占用空间最大一个数据的类型来作为 基本单位

- inline 内联函数的特点有哪些？它的优缺点是什么？

> [内联函数和宏定义](https://github.com/guaguaupup/cpp_interview/blob/main/C%2B%2B.md#inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AE%8F%E5%AE%9A%E4%B9%89)

- 优点
    - 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
    - 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
    - 内联函数在运行时可调试，而宏定义不可以。
    - 可以说inline函数不仅吸收了了C宏定义的，同时消除宏定义的缺点。
- 缺点
    - 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。
    - inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译。
    - 万一又递归调用，代码量很大。

**inline函数代码膨胀的原因？**

> 内联函数是在编译器处理代码时将函数的代码插入到函数调用的位置，而不是像常规函数那样生成一个函数调用语句。这可以提高代码的执行效率，因为减少了函数调用的开销。但是，内联函数也可能导致代码膨胀的问题
>
> **主要是处理函数的时候，谁调用 inline 函数我都直接把函数贴到那里，调用多少次就复制多少份？导致了inline函数的膨胀问题**

- 如何用C 实现 C++ 的面向对象特性（封装、继承、多态）

> 封装、继承本身就有，[C语言实现多态](https://github.com/guaguaupup/cpp_interview/blob/main/C%2B%2B.md#c%E8%AF%AD%E8%A8%80%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81)

- memcpy怎么实现让它效率更高？

> 根据 **位宽** 来加速拷贝的过程、不再是一次性拷贝一个字节，而是多个（比如指针类型转换成 unsigned long* 就可以实现）

- typedef和define有什么区别？

[typedef vs define ](https://github.com/guaguaupup/cpp_interview/blob/main/C%2B%2B.md#typedef%E4%B8%8Edefine%E7%9A%84%E5%8C%BA%E5%88%AB)

- extern有什么作用，extern C有什么作用？

①为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。主要原因是C++和C程序编译完成后在目标代码中的命名规则不同。比如C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。

②extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。

- 如何避免野指针？

> **出现的情形？**
>
> 1. 使用未初始化的指针
> 2. 指针所指向的对象已经消亡
> 3. 指针释放之后没有置空
>
> **如何避免？**
>
> 1. 定义的时候就初始化（或者使用引用）， 或者置空

- 如何计算结构体长度？

> 使用 sizeof 运算符

- sizeof和strlen有什么区别？

>

- 知道条件变量吗？条件变量为什么要和锁配合使用？

[这里有链接](https://github.com/guaguaupup/cpp_interview/blob/main/linux%E6%9C%8D%E5%8A%A1%E5%99%A8.md#pthread_cond_wait-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BC%A0%E9%80%92-mutex-%E5%8F%82%E6%95%B0)

```cpp
while (判断条件) { 
	cond.wait();
}
加锁能够保证 check & wait 是一组原子操作，没有锁的话 check 结束发生了 notify, 但是还没有进行 wait 呢， 本次notify就错过了
  
```



## C++内存管理

> 1. 如果说申请的内存的大小是 小于 `128K` 的那么就直接使用 `brk` 将 heap 的空间往上抬
> 2. 如果说申请的内存的大小是 大于 `128K` 的那么就 使用 `mmap` 从文件映射区域申请内存
>
> - free 的内存如果是从 **堆区** 产生的话并不会直接释放掉而是放回到 mem pool 中
> - 如果说是从 **文件映射区域** 产生的就是直接释放掉
>
> **缺点？**
>
> 频繁的 malloc, free 产生碎片。大量的系统调用的开销，很影响效率
>
> **解决？**
>
> 内存池化技术，使用内存池进行内存的管理
>
> - 因为一次性向内存中申请的内存块是比较大的，所以说能够降低外碎片的问题
> - 同时能够避免频繁的向OS请求内存的操作，减少了 syscall 的次数




## C++基础

- C语言和C++有什么区别？

> C++主要是提供了面向对象的思想，封装、继承、多态

- struct和class有什么区别？

> 仅有 `struct` 的默认权限是 `public`, `class` 的默认权限是 `priavte` 的区别

- extern 关键字？

>①为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。主要原因是C++和C程序编译完成后在目标代码中的命名规则不同。比如C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。
>
>②extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。

- 函数重载和覆盖有什么区别？

> 重载和重写嘛？

- 谈一谈你对多态的理解，运行时多态的实现原理是什么？

> 就是 **一个接口、多种方法**， 用的是同一个接口，但是拥有不同的实现
>
> 运行时多态由虚函数来实现的，继承体系下每一个类是由一个虚函数表的，如果说子类重写了父类的虚函数，那么运行的时候调用的是子类的函数

- 对虚函数机制的理解，单继承、多继承、虚继承条件下虚函数表的结构

> 多继承的话就是俩虚函数表呗

- 如果虚函数是有效的，那为什么不把所有函数设为虚函数？

- 构造函数可以是虚函数吗？析构函数可以是虚函数吗？

[面试系列之C++的对象布局【建议收藏】](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484758&idx=1&sn=4e614430f666f63ab135c13a716d07c1&chksm=c21d37eaf56abefc8d2a1dc3e09a8146d242475cb0900ee5a94ab6a94a991168a887f7351821&scene=21#wechat_redirect)

- 什么场景需要用到纯虚函数？纯虚函数的作用是什么？

> 没有办法实例化，一般是用于接口类或者说抽象类
>
> 使用 `static` 函数

- 了解RAII吗？介绍一下？

[RAII妙用之计算函数耗时](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484795&idx=1&sn=ba7f3ec2787246d1162f0d9565d122b6&chksm=c21d37c7f56abed15d1e843b2da8ff593512bed78d3f83cc6ef6decf86d2b253e5443d91b199&scene=21#wechat_redirect)

[RAII妙用之ScopeExit](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484798&idx=1&sn=88ccc1f9be1712f3dde7a85141981edc&chksm=c21d37c2f56abed474264e47b03f849b80319e459f1ab007552cd7ecaff6c7e42bfcfd1e4d5f&scene=21#wechat_redirect)

- 类的大小怎么计算？

> sizeof

- volatile关键字的作用？[什么时候需要使用volatile关键字](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484767&idx=1&sn=0b45be91a1968c2d564395b6797b81c1&chksm=c21d37e3f56abef5e3e0b9fd8b720bad451e5562aaf0b7d2a1501696f1db7dafe350150aab29&scene=21#wechat_redirect)

- 如何实现一个线程池？[C++线程池的实现之格式修订版](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484800&idx=1&sn=402ac9441890f201a5eb46641307a832&chksm=c21d373cf56abe2aa51c2aa20314a395c86266ae72a0e53fdcbc00d07d9d180308b183a48be0&scene=21#wechat_redirect)

- 了解各种强制类型转换的原理及使用？

>

- 指针和引用有什么区别？什么情况下用指针，什么情况下用引用？

- 一般什么情况下会出现内存泄漏？怎么用C++在编码层面尽量避免内存泄漏。

> 1. 使用了 new, 但是忘记进行 delete => 对于内存的分配和释放尽量成对
> 2. 错误的使用指针 => 尽量使用 `smart pointer`
> 3. 父类的析构函数应该设置成为虚函数

- unique_ptr如何转换所有权？

> `std::move()`

- 谈一谈你对面向对象的理解

- 什么场景下使用继承方式，什么场景下使用组合？

1. **new和malloc有什么区别？**

- malloc的内存可以用delete释放吗？
- malloc出来20字节内存，为什么free不需要传入20呢，不会产生内存泄漏吗？
- new[]和delete[]一定要配对使用吗？[new[\]和delete[]为何要配对使用？](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484815&idx=1&sn=9bb99fdccd9cc31c83c95dd4eedefc46&chksm=c21d3733f56abe25d42b13a3baab12aa4980d0949c19f21139788f77d0a55e66741faa311ab8&scene=21#wechat_redirect)



##  **C++11新特性你都了解多少？**

- 了解auto和decltype吗？[一文吃透C++11中auto和decltype知识点](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484787&idx=1&sn=6b9d5c3b902b87530a4d9efd3ede3612&chksm=c21d37cff56abed9e071db8e2725c2965c84b144cc99bce5f3ec855b7eeb51f7d206862abc73&scene=21#wechat_redirect)

> 都是类型推导，但是一句话总结：**当你需要某个表达式的返回值类型但是不想实际执行它就使用 decltype**

> `decltype` 能够让你获得编译器的类型

- 谈一谈你对左值和右值的了解，了解左值引用和右值引用吗？

> 了解，balabalabalabala

- 了解移动语义和完美转发吗？[左值引用、右值引用、移动语义、完美转发，你知道的不知道的都在这里](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484786&idx=1&sn=fc10ee31da336ec53b23b8be93e847ef&chksm=c21d37cef56abed87c080e610f227742dfbb59b90deca2a09150e2f7dba78ea143dbb3063c47&scene=21#wechat_redirect)

>  **完美转发**：
>
>  能够接受任意实参的函数模板，并且转发到其他的函数，目标函数能够 **收到与转发函数完全相同的实参（左右值的语意是不会进行更替的）**
>
>  **返回值优化：**
>
>  返回值优化(RVO)是一种C++编译优化技术，当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++标准允许省略调用这些复制构造函数。
>
>  那什么时候编译器会进行返回值优化呢?
>
>  - return的值类型与函数的返回值类型相同
>  - return的是一个局部对象



- 了解列表初始化吗？[学会C++11列表初始化](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484784&idx=1&sn=84f3248fd48df7e23d296da8d2491006&chksm=c21d37ccf56abeda5a1fa842ae02b29ca16e3dbed6dc03b8667152e2351afb951bf5c022fcf9&scene=21#wechat_redirect)

> 个人认为列表初始化的好处如下：
>
> 1. 方便，且基本上可以替代括号初始化
> 2. 可以使用初始化列表接受任意长度
> 3. 可以防止类型窄化，避免精度丢失的隐式类型转换

- 平时会用到function、bind、lambda吗，都什么场景下会用到？[搞定c++11新特性std::function和lambda表达式](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484783&idx=1&sn=ddc57fd2753aa386ed1bcf0b7c755699&chksm=c21d37d3f56abec5a9b333d55afd541017fc8c41f74a2bb8009fa341d6a26685c6f08ff5d50c&scene=21#wechat_redirect)

> `function` 其实就是可调用对象，能够接受各种各样的函数，如果实现 **回调机制** 的话基本上是需要使用 `function`
>
> `bind` ：就是能够 **将可调用对象和参数进行一起绑定， 绑定之后的结果能够使用 std::function 进行保存，并且延迟调用到我们需要的时候**
>
> std::bind通常有两大作用：
>
> - 将可调用对象与参数一起绑定为另一个std::function供调用
> - 将n元可调用对象转成m(m < n)元可调用对象，绑定一部分参数，这里需要使用std::placeholders



- 对C++11的mutex和RAII lock有过了解吗？[c++11新特性之线程相关所有知识点](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484782&idx=1&sn=e2f36d7896fe168e17957efea5ecdf21&chksm=c21d37d2f56abec41c8fd9d572778651560424a18622fd742ceadb59f86f9966c081fc388c46&scene=21#wechat_redirect)

> - thread 可以自己写一些 `thread guard` 用于最终析构的时候进行 `join`
> - RAII实现的加锁如 `lock_guard`, `unique_lock`(能够更加灵活，比如说还支持自己 lock unlock, ) 在`condition_variable` 的使用中是必要的

- C++中的多线程原语？

> `future`: 获得线程的返回值，使用 `future.get()` 的时候阻塞，直到线程的函数执行完毕 进行了返回
>
> `async`: 异步执行函数，参数 `async | deffered` 也就是指明了是否是真的开启一个线程去执行函数

- 对C++11的智能指针了解多少，可以自己实现一个智能指针吗？[c++11新特性之智能指针](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484781&idx=1&sn=008834d760aa70559dc4d532a5383107&chksm=c21d37d1f56abec79f5ae0b4ac18a387f8521bda9516761ce29d78780b1dfac8519ce7987316&scene=21#wechat_redirect) [源码分析shared_ptr实现之修订版](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484794&idx=1&sn=90537db3ab4dd888158067941a0bc8b8&chksm=c21d37c6f56abed05754a98f4bf7dbd2b1ee85f4f0e47d0dba2de7ecdc974a2f18fbd46694d0&scene=21#wechat_redirect)

> **为什么使用 make_shared 进行初始化？**
>
> 1. 提高性能：如果说手动的进行 new 一个对象的话，总共需要分配两次内存，而使用 `make_shared`只需要申请一次内存
> 2. 使用 `make_shared` 能够更好的管理各个对象的引用计数等

> **weak_ptr的作用？**
>
> - 解决循环引用问题
> - 多线程环境下探测 `shared_ptr` 对象是否是存活的（因为需要用到对象的函数，但是对象可能已经析构了）

- enum 和 enum class有什么区别？

> 是否是有 **作用域？**

\22. **STL**

- C++直接使用数组好还是使用std::array好？std::array是怎么实现的？

> 使用 std::array 比较好，多了数组访问越界时候的检查，底层就是数组

- std::vector最大的特点是什么？它的内部是怎么实现的？resize和reserve的区别是什么？clear是怎么实现的？

> 动态扩容
>
> **
> 当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间**(gcc是2倍，vs下的mingw是1.5倍)
>
> 当释放或者删除（vec.clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。
>
> 因此，对vector的任何操作一旦引起了空间的重新配置，指向原vector的所有迭代器会都失效了。
>
> - reserve是**直接扩充到已经确定的大小**，可以减少多次开辟、释放空间的问题（优化push_back），就可以提高效率
> - resize是改变容器的大小

- deque的底层数据结构是什么？它的内部是怎么实现的？

> deque 容器存储数据的空间是由一段一段等长的连续空间构成，各段空间之间并不一定是连续的，可以位于在内存的不同区域。
>
> deque是在功能上合并了vector和list。
>
> **优点：**
>
> 1. 随机访问方便，即支持[ ]操作符和vector.at()
> 2. 在内部方便的进行插入和删除操作
> 3. 可在两端进行push、pop
>
> 缺点：占用内存多

- map和unordered_map有什么区别？分别在什么场景下使用？

> 底层是红黑树和哈希表

- list的使用场景？std::find可以传入list对应的迭代器吗？



- string的常用函数




## 操作系统

- 进程和线程的区别？[深度好文|面试官：进程和线程，我只问这19个问题](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484716&idx=1&sn=d9eb61162dab2c6da9b9f153fe4319b4&chksm=c21d3790f56abe8682f52b11ed9a65c7138a4942f34336d3745355d44fffd535eadb13d2b9a4&scene=21#wechat_redirect)

- 操作系统是怎么进行进程管理的？

> 使用 PCB 这个数据结构进行管理，进程其实就是可以理解成为一个 PCB，因为保存了进程相关的状态信息，进程就是资源分配的基本单位嘛

- 操作系统是如何做到进程阻塞的？

> - `spinlock` : if the signal u waiting is **return fast**, this method is useful, 避免了系统调用产生的上下文切换的开销。或者说避免放弃时间片
> - `mutex`: 使用互斥锁来进行阻塞

具体来说，当一个进程或线程需要等待某些事件发生时，它会发起一个系统调用（例如I/O操作），操作系统会将它的状态设置为阻塞状态，并将它从CPU调度队列中移除。此时，操作系统会将CPU分配给其他可执行的进程或线程，从而实现并发执行。

当该事件发生时，操作系统会将该进程或线程的状态设置为就绪状态，将它重新插入CPU调度队列中，等待操作系统分配CPU资源执行。

总之，阻塞是通过操作系统维护进程或线程状态来实现的，它的目的是让操作系统更加高效地利用系统资源，提高系统的并发性能。



- 进程之间的通信方式有哪些？

> 主要是在内核申请一段缓冲区进行通信，如 管道（一般是用来父子进程之间的通信）、消息队列（内核当中开辟的）
>
> **消息队列 VS 管道**：
>
> 消息队列收发消息自动能够保证同步，不需要进程提供同步方法，管道需要自己提供
>
> 消息队列能够根据消息的类型有选择的接收特定类型的数据，不用像管道那样默认接收数据
>
> 消息队列缺点就是发送和接收每个数据都有最大的长度限制
>
> - 共享内存：各个进程之间共享，多进程能够直接读写一块内存空间，**最快的IPC，但是需要自己同步**
> - 信号：在某一时刻发送通知给进程，但是缺点就是只能告知消息的类型是什么
> - 信号量： 原子的操作，主要是用于进程之间的同步
> - socket：

- 什么是上下文切换，操作系统是怎么做的上下文切换？

> [link](https://github.com/guaguaupup/cpp_interview/blob/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E5%8C%BA%E5%88%AB)

- 线程是如何实现的？

> [线程怎么实现的？](https://github.com/guaguaupup/cpp_interview/blob/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84)

- 线程之间私有和共享的资源有哪些？

> 线程的话作为 CPU 的调度的基本单位，私有的部分主要是 寄存器、栈区、thread local
>
> 其余的就是共享的咯，堆区啊、打开的文件啦、各种数据

- 一般应用程序内存空间的堆和栈的区别是什么？

> [内存空间的堆和栈的区别](https://github.com/guaguaupup/cpp_interview/blob/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88)

- 进程虚拟空间是怎么布局的？[10张图22段代码，万字长文带你搞懂虚拟内存模型和malloc内部原理](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484726&idx=1&sn=18d9dc7f8b76a2a9a0b29b39ff6dabea&chksm=c21d378af56abe9c56f3d4da55b4d2d90995bae0e1a4a13c3e5cf7f33473d2642615b445aeb1&scene=21#wechat_redirect)

> [虚拟空间的布局（内存模型）](https://github.com/guaguaupup/cpp_interview/blob/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E5%B8%83%E5%B1%80%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)

- 虚拟内存是如何映射到物理内存的？了解分页内存管理吗？[操作系统内存管理，你能回答这8个问题吗？](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484706&idx=1&sn=f99afd2c8c38d97d0e4d333f9c821143&chksm=c21d379ef56abe881bc15e963ea0a8417fb2e80ca022d86024be1d9dbe6e6009396520031e0d&scene=21#wechat_redirect)

- 产生死锁的必要条件有哪些？如何避免死锁？

> **必要条件**：互斥、占有并且等待、不可抢占、循环等待
>
> **如何避免死锁？**： 资源有序的分配，加锁需要按照顺序来进行

- 什么是大端字节，什么是小端字节？如何转换字节序？

> 大端也叫做网络序，多用于网络的信息传输中，符合人类的阅读习惯（大字节在低地址处）
>
> 小端就符合机器的处理了（低字节在低地址处）
>
> `hton`

- 信号和信号量的区别是什么？

> 都是进程之间通信的工具
>
> - 信号：主要是发送一个通知，但是只能传递消息的类型而不能发送大批量的数据
> - 信号量：主要是用来同步的

- 锁的性能开销，锁的实现原理，锁的优化？

> **锁的本质**： 其实最终就是会落实到两种实现上面
>
> 1. **CAS原子操作：**处理器会按照轮询的方式进行获得锁
> 2. **内核提供的锁机制：** 在被锁住的时候会将当前的线程置于睡眠（阻塞）状态，从CPU队列撤销&加入到阻塞队列？
>
> **所以很容易得到一个结论，如果锁不存在冲突，每次获得锁和释放锁的处理器开销仅仅是CAS指令的开销，在x86-64处理器上，这个开销只比一次内存访问（无cache）高一点（大概是1.3倍）。一般的电脑上一次没有缓存的内存访问大概是十几纳秒**

> **性能开销**：
>
> 上锁和解锁的开销、竞争和饥饿的开销（即等待数据）、内存开销、缓存一致性开销
>
> 线程上下文的开销、调度器开销（线程从运行改成阻塞Or就绪到运行）、上下文切换带来的缓存不命中
>
> [锁的开销](https://github.com/guaguaupup/cpp_interview/blob/main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md#%E9%94%81%E7%9A%84%E5%BC%80%E9%94%80)
>
> **futex是什么？（fast Userspace mutexes）**
>
> 内核态和用户态的混合机制，`futex` 能够通过用户态检查，如果了解到没有竞争就不需要陷入内核了，大大提升了效率（避免了大量的陷入内核的开销）
>
> CAS是用户态的 CPU 指令，若无竞争，简单修改锁状态即返回，非常高效，只有发现竞争，才通过系统调用陷入内核态。所以，FUTEX是一种用户态和内核态混合的同步机制，它保证了低竞争情况下的锁获取效率。
>
> 如果每次检查都需要陷入内核（即使没有产生冲突）， 那么开销实在是比较难以接受

**锁的优化？**

> 上锁的次数不是主要的瓶颈（只是CAS没什么的），主要是 **冲突的产生**
>
> - 减少粒度：比如说B+树可以用一把大锁（效率实在太低），一般是用 `node latch`
> - 尽量的减少 `critial section ` 的范围

- 了解CPU的Cache吗？如何写一个高效的多维矩阵乘法？[如何利用CPU Cache写出高性能代码，看这些图就够了！](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484740&idx=1&sn=d8fc981374061ed8d75b9e29cd6d16da&chksm=c21d37f8f56abeee9cc7594ab57bc3694984f00a363ad4cbbd5f0ecc5554628e793eed25a120&scene=21#wechat_redirect)

**CPU的cache的写入策略**

> - **write through:** 数据更新的时候，将数据同时写入 内存 & Cache，策略简单并且每次都需要写入内存
> - **write back：** 数据更新的时候写入 Cache，数据被替换出 Cache 的时候，才将数据写回到内存中。因为不需要直接写到内存中所以说速度比较快，但是会出现 **内存与Cache中数据不一致**的情况

**Cache 一致性？**

> SEID？也就是标识了一下 cache 是不是脏的，如果脏的话（cache内容同内存中不同）读取该部分对应的内存需要首先将cache中的内容写到内存中



### File System

**文件系统的基本组成**

> 一般来说对于一个文件分配两个数据结构：`inode`, `directory entry` ,主要是用来记录文件的元信息和目录层次结构
>
> - 索引节点，也就是 `inode`, 用来记录文件的元信息如 创建时间、修改时间、**数据在磁盘的位置**，
    >
    >   它是文件的唯一标识，同样也是存储与磁盘中
>
> - 目录项，也就是 `dentry`,  **用来记录文件的名字**
    >
    >   当然，一个文件的名字可以有多个，所以说 **目录项和inode的关系是多对一的联系**
    >
    >   数据并不存放在磁盘中，缓存在内存中



![Screen Shot 2023-04-06 at 2.43.48 PM](/Users/shaoguixin/Desktop/Screen Shot 2023-04-06 at 2.43.48 PM.png)



- *超级块*，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。
- *索引节点区*，用来存储索引节点；
- *数据块区*，用来存储文件或目录数据；

### 虚拟文件系统

> 对于用户提供了一个统一的接口， 在用户层和文件系统层引入了一个中间层：**虚拟文件系统**
>
> 文件系统首先是需要挂载到某个目录上面才可以正常使用，比如 Linux 系统在启动的时候会把文件系统挂载到根目录。

**文件的使用**

> 我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统为每个进程维护一个打开文件表，文件表里的每一项代表「**文件描述符**」，所以说文件描述符是打开文件的标识。
>
> 文件系统的基本操作单元是 **数据块**，用户使用的时候习惯以 **字节** 的方式对于文件进行读写。所以说VFS就需要对于这个进行屏蔽嘛，就像数据库以 `Page` 为基本的单位,但是你能够只改一条数据

**文件的存放**

> - **连续空间存放**：文件存放在磁盘 【连续的】物理空间中，这样 **读写的效率高**，因为磁盘的 **寻道** 时间是很短的。当然前提就是：**需要知道文件的大小**。
    >
    >   **缺点：** 连续空间存放的方式虽然说读写效率是比较高的，但是存在 「磁盘碎片🧩」和「文件长度不容易拓展」的缺陷。就是如果一个文件被删除了但是删除的地方出现了一个 **洞**， 大小不合适的话别的文件也没办法用。因此这种实现是不可接受的（外部碎片🧩）
>
> - **非连续空间存放**： 链表 balabalabala

**软连接和硬连接**

> 有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过**硬链接（Hard Link）** 和**软链接（Symbolic Link）** 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。

> 硬链接是**多个目录项中的「索引节点」指向一个文件**，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以**硬链接是不可用于跨文件系统的**。由于多个目录项都是指向一个 inode，那么**只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。**

> 软链接相当于重新创建一个文件，这个文件有**独立的 inode**，但是这个**文件的内容是另外一个文件的路径**，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以**软链接是可以跨文件系统的**，甚至**目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。**



## 编译原理

- gcc hello.c 这行命令具体的执行过程，内部究竟做了什么？[gcc a.c 究竟经历了什么？](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484769&idx=1&sn=6db2570301a2500d8edc88a2263e6570&chksm=c21d37ddf56abecb7100571ab45863cdf5e54142c561f698478984f8093ee413db44e9da9b9a&scene=21#wechat_redirect)

- 程序一定会从main函数开始运行吗？

- 如何确定某个函数有被编译输出？

> 1. 使用静态分析的工具，能够判断是否是被编译输出了
> 2. 在代码当中加上一些调试的信息，如输出一些字符串啥的
> 3. 使用宏定义进行处理，在需要判断的函数内部加上一些宏定义来实现检查

- 动态链接库和静态链接库的区别是什么？[Linux 为什么要动态链接？与静态链接的区别是什么？](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484762&idx=1&sn=c9d0b06501c83173c91d3dbe90ec3898&chksm=c21d37e6f56abef00b0708cbe680454e8957ba4480931797e03126aae46572f8dd62304f13b6&scene=21#wechat_redirect)

> **静态链接的缺点：**
>
> 1. 因为静态链接有缺点，会很**浪费内存 & 磁盘空间**。如果说两个程序都需要用到 `lib.o` 模块，同时链接输出的可执行文件当中是有 **两个副本的**， 同时运行的时候 **副本同时存在多份**
> 2. 对于部署和发布十分不友好，如果说一个模块进行了更改，那么所有的模块都需要重新进行编译
>
> **为什么要进行动态链接？****为了解决静态链接浪费空间和更新困难的缺点。**
>
> **动态链接的方式？****装载时重定位和地址无关代码技术。**
>
> **地址无关代码技术原理？****通过GOT段实现间接跳转。**
>
> **延迟加载技术原理？****对外部函数符号通过PLT段实现延迟绑定及间接跳转。**
>
> **如果进行显式运行时链接？****通过<dlfcn.h>头文件中的四个函数，代码如上。**

# C++编译过程

`C++`是一种高级编程语言，但是计算机并不能直接理解它。因此，需要将`C++`代码翻译成计算机可以理解的机器语言。这个过程就是编译过程，是`C++`程序从源代码到可执行文件的转换过程，包括**预处理、编译、汇编和链接**四个阶段。

## 1. 预处理

在编译器开始编译之前，会先进行预处理。预处理器会处理代码中的所有预处理指令，例如`#include`和`#define`等。它会将这些指令替换成对应的代码，生成一个新的文本文件。这个新的文本文件就是编译器的输入。在预处理的过程中，还会进行条件编译，即根据条件来选择是否编译某些代码块。预处理完成后，会生成一个没有宏定义和条件编译的中间文件。

预处理器的主要作用是解决代码中的宏定义，它会将宏定义展开成对应的代码。此外，预处理器还会处理`#include`指令，将指定的头文件插入到源文件中，以便让编译器能够对头文件中的函数和变量进行编译。

## 2. 编译

编译器将预处理后的文件作为输入，对其进行词法分析、语法分析和语义分析等处理。这些处理会将代码转化成中间代码，中间代码是一种类似于汇编语言的低级代码。编译器将代码分成多个模块，每个模块编译成一个对象文件。在编译的过程中，编译器会对代码进行优化，以提高程序的运行效率和节省内存空间。

在词法分析和语法分析的过程中，编译器会对代码进行检查，以确保代码的正确性和合法性。语义分析的任务是在代码的语法结构上进行分析，以确定代码的含义和作用。

## 3. 汇编

中间代码会被汇编器转化成机器语言指令，这些指令可以被计算机直接执行。汇编的过程将每个对象文件转换成机器语言的目标文件。每个目标文件包含机器指令和数据，以及其他的控制信息。目标文件可以被链接器用于构建可执行文件。

汇编器的主要任务是将中间代码翻译成机器语言指令，以便让计算机能够执行代码。在这个过程中，汇编器会将每个源文件编译成一个目标文件，然后将所有的目标文件组合成一个可执行文件。

## 4. 链接

在编译过程中，可能会用到其他的库文件和对象文件。链接器会将这些文件与生成的可执行文件进行链接，生成最终的可执行文件。链接器的主要任务是解决符号引用问题，即通过在不同的目标文件中查找符号的定义，使得所有的符号都能够正确地被解析和链接。链接器还会对代码进行优化和压缩，以减小可执行文件的体积，并提高程序的运行效率。

链接器的工作包括将每个目标文件中的符号解析成地址，并将它们组合成一个单独的地址空间。链接器还会处理代码中的重定位信息，以确保代码能够正确地加载和执行。

## 结论

`C++`编译过程是一个非常复杂的过程，它需要经过多次处理才能最终生成可执行文件。但是，了解这个过程对于理解`C++`代码和调试程序都非常有帮助。在实际的开发中，程序员需要掌握编译工具链的使用，以便能够更好地进行调试和优化。同时，程序员还需要了解编译器的工作原理和优化技术，以写出高效的`C++`代码。



## Redis

**Redis是单线程的？**

> - 单线程指的是 **[接收客户端请求->解析请求->数据读写等操作->发送数据给客户端]** 的过程是（主线程）完成的
> - Redis启动的时候会有很多 **后台线程**： 如 **AOF刷盘、处理关闭文件、LazyFree线程**
> - 后台线程就是 “消费者”， 不断的获取前台 “生产者产生的耗时任务” 去执行，避免阻塞前台

**为什么单线程还能够那么快？**

> - Redis 是内存的数据库，大部分操作都是在内存中完成的，瓶颈是**内存或者带宽**，并不是CPU。既然说瓶颈不是CPU那么不需要多线程
> - 如果说使用多线程模型 避免不了 **多线程之间的竞争、线程切换的开销**
> - Redis使用 **IO多路复用** 处理客户端的 Socket 请求，够用了

**Redis怎么实现数据不丢失的？**

> - **AOF日志、RDB快照、混合持久化方式**

**AOF日志怎么实现的？**

> Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复

**为什么先执行命令，再写数据到日志？**

> - 避免额外的检查开销：能够执行的话肯定是合法的
> - **不会阻塞**当前操作的写命令

**AOF的刷盘策略？**

> - **Alaways：**每次写入命令执行完毕之后， **同步的将日志数据写入到磁盘中** `fsync`
> - **EverySec**: 写入命令执行完毕之后，先将命令写入到 AOF 文件的内核缓冲区内部，然后每隔一秒将缓冲区的内容写回到磁盘中
> - **No：** 完全由 OS 进行操控写入到磁盘的时机
>
> *其实就是什么时间应用`fsync` 函数*
>
> `Alaways` 就是每次写 AOF 文件数据之后都是直接调用 `fsync` , **同步等待**数据刷盘的结束
>
> `EverySec` 就是创建异步任务执行 `fsync` 函数
>
> `No` 就是不执行 `fsync` , 全部都是由 OS 来把握， 例如说只是 调用 `fflush`, 刷到缓冲区中，刷盘由OS调度

**如果说AOF日志过大，会触发什么机制？**

>  如果说AOF日志文件过大， 那么 **在进行恢复的时候恢复的过程是很慢的**， 所以说就有了 **重写机制**
>
>  比如说一个数据在整个过程中按照时间来说 存在多份，我们只是保留 **最新的数据** 就好了
>
>  这就相当于对日志进行了压缩

**重写 AOF 日志的过程？**

> Redis 的 **重写AOF**  是由 **后台子进程 bgrewriteaof** 来完成的

*为什么使用子进程来进行重写而不是子线程？*

> 使用子进程的话，在调用 `fork` 的时候会复制页表，父子进程之间的物理内存是共享的

> - 子进程进行 AOF 重写期间，主进程能够继续处理命令请求，从而**避免阻塞主进程**
> - 如果说使用线程来操作的话，因为很多东西是共享的，所以说修改数据的时候需要额外的通过 **加锁** 来保证数据的安全，会降低性能。
> - 使用进程的话就不会了，共享内存数据（不过是只读的），当需要进行数据的修改的时候直接进行 **写时复制** ，子进程就有了独立的数据副本，不需要通过加锁来保证数据安全

**重写的时候会不会阻塞主进程？**

> - `fork` 的时候会对于页表进行
> - 发生**写时复制**的时候会阻塞主进程
> - 信号处理的时候会对于主进程造成阻塞

**RDB快照怎么实现的？**

> 因为 AOF 记录的是操作，在数据需要进行恢复的时候需要先将 日志都给执行一遍，恢复的肯定不如 **快照**的效率高
>
> 所以说 RDB 就是记录**某一个瞬间的 内存**的数据，其实也就是实际的数据，而AOF记录的是 **命令操作**

**RDB 做快照的时候会阻塞线程吗？**

> Redis 提供了 `save` & `bgsave` 来生成 `RDB`文件，区别的话就是 是否在 [主线程] 里面执行。。。
>
> - 如果说执行 **save** 命令，在主线程生成 RDB 文件，写入RDB时间太长的话就会 **阻塞主线程**
> - 执行了 **bgsave** 命令，创建一个子进程来生成 RDB 文件，能够 **避免主线程的阻塞**

**RDB执行快照的时候，数据能够进行修改吗**

> 当然能啦，就是前面提到的 `copy on write`, 因为是不同的 进程嘛，共享内存
>
> 如果说主进程进行了数据的修改，直接将对应的页表复制给主进程就好了 [cow介绍](https://blog.csdn.net/qq_52245648/article/details/127443523?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168051194616800188591682%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=168051194616800188591682&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-127443523-null-null.blog_rank_default&utm_term=cow&spm=1018.2226.3001.4450)

**RDB和AOF混合使用**

> RDB的**恢复速度**是比 AOF 快的， 但是快照的频率把握不好掌控
>
> - 如果说频率太低：两次快照之间一旦服务器宕机，较多的数据丢失
> - 如果说频率太高：频繁的写入磁盘和创建子进程会带来**额外的性能开销** （生成RDB快照不容易啊）



## Redis 高可用

### **主从复制是怎么实现的？**

数据都是存在于一台服务器上面的，如果说出事就完犊子了

- 服务器发生了宕机，数据恢复需要时间，这一段时间内是**不能够服务新的请求**的
- 硬盘出现了故障，数据真的就丢失了

> 我们为了避免这种 **单点故障**， 最好的方式就是对于数据进行备份

**数据怎么保证一致性呢？数据的读写是每一台服务器都能够进行处理吗?**

> - **数据修改只能是在主服务器**上面执行，将最新的数据同步给从服务器, 一般来说 **从服务器是只读的**，数据从主服务器更新之后 **异步的** 将数据同步给 从服务器。
>
> - 因为是 **异步的将数据发送给从服务器**， 所以说没有办法实现 **强一致性** ，数据不一致是难以避免的

### 主从复制的具体实现？

**第一次同步**

> 首先是 **从服务器** 执行 `slaveof` 命令形成对于指定的 **主服务器** 的`隶属于` 的关系
>
> - 第一阶段：建立连接、协商同步

> 执行了 `slaveof` 命令之后从服务器发送 `psync` 请求主服务器的数据，带有参数 **主服务器的ID** ，**复制进度 offset** 。然后主服务器回送 **FULLRESYNC** 进行 **全量复制**

> - 第二阶段：主服务器同步数据给到从服务器

> 想要同步主服务的数据给到从服务器的话，首先想到的可能就是 **RDB** 快照发送给从服务器（bgsave），然后就能够同步当时的数据给到从服务器。
>
> 那么如果生成RDB的时候， **新的数据怎么办？是不能够同步给从数据库的，会产生数据不一致的情况**
>
> 主服务器再记录新的数据到 **buffer** 中，然后传递给从服务器就好了

> - 第三阶段：主服务器发送新写操作命令给从服务器
>
> 主服务器将 RDB 文件传送给从服务器 & 传送 buffer 中的数据

**命令传播？**

> 之后的话就是通过 TCP 连接进行命令的同步， **使用TCP长连接进行命令的传输避免TCP连接的频繁创建和断开**

**主节点压力大？**

> 增设 `manager node` 帮助主节点进行均衡就好了
>
> 如果遇到了网络的问题导致了连接的断开，为了维持数据的一致性需要进行 **增量复制**



### 哨兵模式？

**为什么需要哨兵模式？**

> 在使用 Redis 主从服务器的时候有一个问题：当 Redis 的主从服务器出现宕机时候，需要手动的进行恢复
>
> 能不能系统自己处理好呢？ Redis 增加了哨兵模式，能够 **监控主从服务器、提供主从节点故障转移功能**

**哨兵模式是怎么工作的？**

> 哨兵节点的工作主要负责三件事情：**监控、选主、通知**
>
> - 哨兵节点怎么监控新的节点的？怎么判断主节点是否真的故障了？
> - 根据什么规则进行的选主？
> - 怎么把新主节点的相关信息通知给从节点和客户端？

**怎么判断主节点是真的故障了？**

> - 哨兵会每隔一段时间发送 `PING` 命令给到各个节点，当节点收到了 `PING` 命令之后会发送响应数据给到哨兵，这样来判断是否是正常运行的。
>
> - 但是，如果说哨兵没有收到响应报文只能是判断为 **主观下线（也许节点没挂，只是网络延迟）**
>
> - 所以说判断节点是否是真的下线了需要 **集群**  来进行统一的判断（最少需要三台机器来进行判断）
> - 当一个哨兵发现主节点是 **主观下线了**， 会向剩余的哨兵节点发起命令，投票表明主节点是否下线
> - 当大部分的哨兵都认为主节点挂掉了，那么就需要从【从节点】中选出一个成为新的主节点了

**由哪个哨兵进行主从故障的转移？**

> 主节点的挂掉 是由 **哨兵集群** 的方式进行判断的，那么哨兵集群中的哪一个节点作为 **集群中的 Leader** 来操控整个故障转移的过程呢？
>
> 所以说我们还需要从 **哨兵集群** 中选举出来一个 `Leader`

**怎么进行选举 哨兵集群 中的 Leader？**

> - 首先是 `candidate`, 如果说哨兵节点感知到了 主节点宕机了，那么就成为一个候选者，当然如果多个节点同时感知的话就有多个 `candidate`
> - `candidate` 向剩余的节点发起 `vote`, 收到投票比较多的 `candidate` 成为 `sentinel Leader`
> - 需要注意的是【候选者】需要满足 **（半数以上的票数、票数大雨配置文件的quorum值）**

**主从故障转移是怎么实现的？**

> 1. 在已经下线的【主节点】（旧的主节点）属下的所有【从节点】里面挑选出来一个从节点并转换为主节点
> 2. 让已经下线的【主节点】的所有的【从节点】修改复制目标`slaveof` 为新的主节点
> 3. 将新的【主节点】的IP地址和信息通过【发布者/订阅者机制】通知给客户端
> 4. 监视【旧主节点】，重新上线的时候设置成为【新主节点】的【从节点】

**step1:选出新的主节点**

> 故障转移的话需要从诸多从节点中选出来一个 【状态良好、数据完整的】从节点，然后这个从节点就晋升为主节点: `slaveof no one`, 实现了【从节点】到【主节点】的切换
>
> 选择哪一个从节点呢？随机可以吗？
>
> - 随机是不行的，如果选择了一个**状态比较差**的【从节点】的话过不了多久又要进行选主了
> - 我们可以首先排除一部分肯定不能中选的：例如网络状态比较差的节点（之前维护了一个数值就是主从服务器之间的断连次数，如果断连比较多次的话我们可以认为网络比较差）
>
> **接下来我们有3个指标进行节点的选取**
>
> - First round: 哨兵节点首先根据从节点的优先级进行排序，优先级越小的越靠前
> - Second round: 优先级如果相同的话，查看 **复制的进度（offset）**, 复制进度比较大的优先
> - Third round： 如果优先级和下标都相同，选择节点的ID比较小的

**step 2：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；**

**step 3：将新主节点的 IP 地址和信息，通过「发布者/订阅者机制」通知给客户端；**

**step4：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；**



### Linux Page Cache

[文章链接🔗](https://spongecaptain.cool/SimpleClearFileIO/1.%20page%20cache.html)



## 海量数据处理

**1.怎么从大量的 URL 中找出相同的 URL ？**

给定a b两个文件，各自存放50亿个URL，每个URL占用64B， 内存限制是4G。找出两个文件中的相同的URL

> - 排序？使用外部归并排序进行操作
> - Hash：遍历文件，对于URL进行哈希映射，相同的URL会被映射到相同的文件中的
> - 字典树：使用 `Trie`树进行数据的存储，因为URL的相差不大，能够极大的降低存储的成本

**2.怎么从大量数据中找到高频词？**

有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。

> 1. 还是需要将文件进行切分，每一个小文件的大小是小于 1M 的
> 2. 遍历文件，将遍历到的词 `x` 进行 **哈希计算** ，最终的数据映射到其他的文件中（这样所有相同的数据是能够映射到同一个文件中的），如果单个文件的数据量太大就按照同样方式继续分解
> 3. 使用 哈希表进行数据频次的计算
> 4. 创建一个 **小顶堆** 来维护 `Top 100`

**3.怎么找出某一天访问百度网站最多的 IP？**

现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。

> - 使用哈希映射，将相同的 Ip 映射到同一个文件中去
> - 哈希表统计词频
> - 维护一个堆（这里就是最多的话用一个变量就好了）

**4.如何在大量的数据中找出不重复的整数**

在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。

> - 分治：还是划分为不同的小文件 然后使用哈希映射，找出每一个小文件中的不重复整数就好了
> - 位图：比较节省空间 而且也算是进行了自动的排序了

**5.如何在大量的数据中判断一个数据是否是存在的？**

> - 布隆过滤器
> - 使用 Trie 树进行构建，能够快速的判断是否是存在的
> - Hash 映射？







## 负载均衡？

### 负载均衡的优势？

> - 应用程序的可用性
>
> 比如说有的服务器宕机了，负载均衡能够自动检测服务器的问题并且将客户端的流量重定向到可用的服务器
>
> - 应用程序的可拓展性
> - 应用程序的安全性
> - 应用程序的性能



### 1.一致性哈希

**什么情况下需要使用一致性哈希？**

> 比如说大量的集群来提供服务，但是一个客户进行请求服务的时候需要同一个 `server`进行服务，所以说可以利用 **Hash % N** 映射到同一个 `server`
>
> 但是，如果集群的数据进行了 **扩容 Or 缩容**，直接 % N就不太对了，如果说迁移的话需要 M 次，成本太高
>
> 为了解决如上，使用一致性哈希（避免过多的数据的迁移）

**能够提供什么？**

> - 如果说节点不新增 Or 不删除，同一个 `client` 永远能够被分配到同一个节点处理
> - 能够有效的分散 “新增” 或者 “删除” 带来的波动性(一个节点新增或者离开都只会影响附近的节点)
> - 虚拟节点的使用可以更加有效的分散波动性

**特性1：**

> 首先是 `server` 能够均分到哈希环中，在 `client` 要求处理的时候获得哈希值
>
> 按照顺时针的方式寻求对应的 `server` 就好了，如果说 `server` 并没有 **新增或者减少**的话那么就能够满足特性1

**特性2:**

> 新增、删除都是只会影响相邻的节点，重新映射就好了

**特性3:**

> 节点分布在 哈希环上面是 **不均匀的**， 会有大量的请求集中在一个节点上面（造成了负载不均衡）
>
> 使用多个虚拟节点，例如节点A有10个虚拟节点，所有请求这些虚拟节点的请求都是由 A 来完成

### 2. Task Steal

> 像线程池的实现中就使用了 **任务窃取** 来将 `task` 尽量的进行 均衡的划分







## 网上的面经？

阿里二面（智能信息）

太难了。。。。
\1. 浏览器内核是什么？有哪些组成部分？
\2. 市面上集中常见浏览器和对应的特点，什么浏览器有什么内核
\3. windows上的异步读有什么优势？
\4. epoll的优势在哪呢？
\5. 对应高并发有什么对应的设计技巧？
\6. 虚拟内存和物理内存的区别
\7. 操作系统的内核直接访问物理内存嘛？
\8. 内存管理分页分段之间的区别和联系
\9. 假如X86的架构，分段在Linux系统下的应用
\10. "简述一下线程池的作用，以及实现，哪些语言有哪些内置的线程池"
\11. 线程池怎么使用？
\12. 用户空间主动唤醒线程和内核唤醒线程？
\13. 如果要开发一个python的文件，寻找文件夹里重复的文件，怎么设计才能达到最高的性能？
\14. python全局解释锁，python多线程无法同时执行，你怎么解决？
\15. 线程池的唤醒，除了信号量，还有什么方法能唤醒线程？




1、自我介绍

2、你的web服务器项目是课程设计还是自己搞的项目（参考开源项目，相关书籍边学习边完成的）

3、介绍一下项目的背景、目的、最终结果是怎样的

4、在github上面有挺多web服务器的项目，你是拿开源的项目修改，还是自己从头写的

5、这里面你在开源项目的基础上，自己做的优化有哪些

6、你能描述一下整个web服务器的设计吗，比如说用了哪些类（或者说是模块），这些类（模块）之间有什么关系，以及它为什么要这样设计（这题答得不是很好）

7、状态机的工作流程

8、设计一个状态机的核心关键的要点/要素是什么，一个状态机很重要的一些设计思路

9、假设现在让你继续去优化这个项目，你有什么想法或者方向吗

10、在功能上面，你的服务器有什么需要完善的

11、你的服务器和市面上成熟的商用服务器有什么样的差异（说部署在多台服务器上乱说了一些分布式的概念，给自己挖了坑）

12、开始简历另一个项目（课程设计，图书管理系统），假设我要增加一个借书的功能，要怎么去设计

13、有了解过类的设计原则，假如说要设计一个类，要注意哪些东西，划分不同的类根据什么原则划分（答得很差）

14、有了解编译原理方面的知识吗

15、C++的编译链接过程是怎么样的，四个关键的步骤是什么

16、缺页中断你有了解过吗

17、每一个可执行文件在linux中通过enf格式去排列的，分段加载到内存里面去的，假设程序在执行代码过程中，这一行代码还没加载到内存，它可能会产生缺页中断，这种情况有没有办法去优化呢，减少缺页中断的发生。（提示了在编译的时候做些什么事情，还是没答上来）

18、除了简历的项目之外，平常有没有做过一些业余的项目（用它解决一些日常的问题），或者说自己的一些兴趣爱好开发的一些项目。

19、移动端的像安卓或ios的有了解吗

20、假设现在要去学习安卓开发，你会怎么学习呢，学习途径，学习方法。

21、在团队竞赛经历中扮演什么角色和职责，有什么印象深刻的事情



\1. 多态的程序，判断输出
\2. 给一棵树和一个sum，判断是否存在从root到叶子结点的path之和等于sum
\3. LRU的实现（双向链表+哈希）
八股：
\1. 上面LRU在多线程时存在什么问题？如何解决？用锁来解决，如何提高效率？举个例子：os里的pagecache页面换入换出，多线程下如何提高效率？
\4. C++的内存泄漏以及解决办法？
\5. Reactor模型的理解
\6. 磁盘IO？什么情况下会发生磁盘IO
\7. Direct IO
\8. buffer read
\9. 有两个文件，key文件和record文件，key文件2G，record文件很大无法读入内存，如何做到随机访问记录？
\10. 动态链接库和静态链接库
\11. 倒排索引你了解吗？





虚函数基本概念
虚函数底层原理（虚函数表和虚函数指针）
早期的智能指针auto_ptr为什么被废弃
现在的能指针有哪几种，应用场景是什么

手撕算法
删除链表中的某个节点（要求考虑全面：head为空、target为空、target=head等等，最后记得delete dummy虚假头节点）
实现Vector类，要求实现这些方法：初始化、整体拷贝、push_back、pop_back、vector[pos]获取指定位置的元素



